
enclave {
	// Import the Ocalls for trusted mutex
	from "sgx_tstdc.edl" import *;
	
    trusted { 
		public int ecall_prads_initialize([user_check]void *global_config, 
                                          int _nets, [user_check]void *_network,
                                          [user_check]void *_os_asset_pool, [user_check]void *_serv_asset_pool, [user_check]void *_asset_pool);
		public void ecall_prads_gameover();
		public uint64_t ecall_prads_cxtrackerid();

        // secure ferry
        public void ecall_secure_ferry(//[in, size=24, count=ferry_unit]void *pheader, 
                                       //[in, size=1604, count=ferry_unit]void *packet, 
                                       [user_check]void *pheader,
                                       [user_check]void *packet,
                                       int ferry_len, int ferry_unit,
                                       [in, size=16]uint8_t *ferry_mac,
                                       [out, size=4]int *miss_count, 
                                       [out, size=4]int *bundle_count,
                                       [out, size=4]int *state_count);

        // naive processing
        public void ecall_naive_process(//[in, size=24]void *pheader, 
                                        //[in, size=1604]void *packet, 
                                        [user_check]void *pheader,
                                        [user_check]void *packet,
                                        int packet_len,
                                        [in, size=16]uint8_t *mac,
                                        [out, size=4]int *state_count);

        // secure ferry trick
        public int ecall_auth_enc([user_check]uint8_t *src, int src_len, 
                                  [user_check]uint8_t *dst, [user_check]uint8_t *mac);

        // flow expiration checking
        public void ecall_sync_expiration(int expired_state_count);
        public void ecall_check_expiration(long wall_time);

        // log agency
        public void ecall_log_flush_timeout([out, size=buf_len]void *out_buffer, int buf_len);

		// stunn thruput test
		public void ecall_init_aes_gcm();
		public void ecall_test_mb();
		public double ecall_etun_start(int record_size, int record_per_batch);

		// state management test
		public void ecall_state_test();

		// entry point of lightbox prads
		public void ecall_lb_prads_init([user_check]void *global_config, int _nets, [user_check]void *_network,
								        [user_check]void *_os_asset_pool, [user_check]void *_serv_asset_pool, [user_check]void *_asset_pool);
		public void ecall_lb_prads_run();

        public void ecall_process_test_round([user_check]void *pkt, [user_check]void *hdr);
    };

    untrusted {
		void ocall_print_string([in, string] const char *str);
		
		void ocall_get_time([out, size=4] int *second,
							[out, size=4] int *nanosecond);

		void ocall_sleep(long time_ns);

		void ocall_random([out, size=4]uint32_t *r);

        // state orchestrator
        void ocall_secure_state_swap([in, out, size=512, count=bundle_size]void *_bundled_state,
                                    [in, size=16, count=bundle_size]void *_bundled_id,
                                    [out, size=4, count=bundle_size]int *is_server,
                                    int bundle_size);

        // Host memory allocation, trick for asset
        void *ocall_calloc(int size);
        void ocall_free([user_check]void *ptr);

        // log agency
        void ocall_log_flush_full([in, size=buf_len]void *buffer, int buf_len);

		// stunn, batch must be a multiply of record
		//void ocall_lb_etun_in_memory([out, size=8]uint8_t **batch);
		//void ocall_lb_etun_in_sim([out, size=8]uint8_t **batch);
		void ocall_lb_etun_in([out, size=8]uint8_t **batch);

		// state management
		void ocall_state_store_alloc([out, size=8]void **store_new);
		void ocall_state_store_free([user_check]void *item);
    };

};
